# 기본 개념
Elasticsearch의 핵심이 되는 몇가지 개념에 대해 알아보겠습니다. 처음에 이러한 개념을 이해하고 계시면 나머지 학습하는데 도움이 많이 될 것 입니다.

## 준실시간 *Near Realtime(NRT)*
Elasticsearch는 준 실시간 검색 플랫폼 입니다. 문서가 검색가능하기까지 색인하는데 1초 이하의 아주 작은 시간이 걸린다는 것을 의미합니다.

## 클러스터 *Cluster*
클러스터는 전체 데이터를 가지고 모든 노드간의 통합 인덱싱 및 검색이 가능한 1개 이상의 노드(서버)집합 입니다. 기본값이 *elasticsearch*인 유니크한 이름으로 구분 됩니다. 클러스터 이름이 중요한 이유는 각각의 노드가 1개의 클러스터에 속해질 수 있으며 설정될 때 클러스터 이름을 가지고 구성이 됩니다.

권고드리는 것은 다른 환경일지라도 동일한 클러스터 이름으로 구성을 하지 마시기 바랍니다. 그렇지 않으면 결국에는 각각의 노드가 원치 않은 다른 클러스터에 구성될 수 있습니다. 예를 들면, 개발, 스테이징, 운영 환경에 대한 클러스터가 필요한 경우에는 개발은 ```logging-dev```, 스테이징은 ```logging-stage```, 운영은 ```logging-prod```로 구분하시기 바랍니다.

1개의 노드를 가지는 1개의 클러스터로 구성해도 문제 없고, 유니크한 이름을 가지는 다수의 클러스터로 구성해도 좋습니다.

## 노드 *Node*
노드는 클러스터의 부분이 되는 단일 서버로써, 데이터를 저장하고 클러스터에 참여하여 인덱싱과 검색 역할을 수행합니다. 클러스터와 같이 노드가 기동될 때 랜덤 UUID(Universally Unique IDentifier)를 기본값으로 하여 각각의 노드를 식별합니다. 기본값을 원치 않는다면 각각의 노드에 명명할 수 있습니다.

노드는 클러스터 명을 가지고 참여여부를 설정합니다. 별도로 정의하지 않는다면 ```elasticsearch```라는 클러스터명을 가지고 노드가 구성됩니다. 그 의미는 아무런 설정없이 동일 네트워크 상에서 다수의 노드를 기동하게 된다면, ```elasticsearch```라는 이름으로 단일 클러스터가 자동으로 구성이 되는 것 입니다. 네트워크 상에서 어떤 노드가 클러스터에 구성되었는지 관리하기 쉽게하려면 각각의 노드에 이름을 정의하는 것을 추천합니다.

단일 클러스터에서 원하는 많큼 다수의 노드를 구성할 수 있습니다. 게다가 현재 네트워크에 기동중인 다른 노드가 없는 상태에서 노드 하나를 기동시키면 자동으로 ```elasticsearch```라는 단일 클러스터를 만들게 됩니다.
## 인덱스 *Index*
인덱스는 비슷한 형질을 가지는 문서 간의 집합이라고 보시면 됩니다. 예로들면 고객정보, 제품카탈로그, 주문정보 같은 것 입니다. 소문자로 구성된 이름으로 구분이 되며 인덱스 이름은 문서에 대한 인덱싱/검색/갱신/삭제 등을 수행할 때 참조값으로 사용됩니다.

단일 클러스터에서 원하는 대로 다수의 인덱스를 정의할 수 있습니다.
## 타입 *Type*
인덱스안에 1개 이상의 타입을 정의할 수 있습니다. 타입은 당신이 정의한 의미기준으로 인덱스를 논리적 분류/파티션입니다. 일반적으로 문서의 공통 속성들을 가지고 정의됩니다. 예로 블로그 시스템을 구성하고 단일 인덱스에 모든 데이터를 구성한다고 하면 타입은 사용자, 블로그, 댓글로 구분될 것 입니다.
## 문서 *Document*
문서는 인덱싱된 정보의 기본 단위입니다. 예로 하나의 고객 정보, 제품 정보, 주문 정보 입니다. 문서는 어디든 호환이 가능한 JSON(JavaScript Object Notation)으로 구성됩니다.

인덱스/타입과 함께 원하는 만큼의 문서를 저장할 수 있습니다. 문서는 물리적으로 인덱스에 있기는 하지만, 필히 인덱스 안에 있는 타입을 기준으로 인덱싱/할당 되어야 합니다. 
## 파편 & 복제본 *Shards & Replicas*
인덱스는 자체로는 단일 노드의 하드웨어 한계를 초과하는 정보를 저장할 수 있어야 합니다. 예로 백만개의 문서 인덱스는 아마 1TB 정도의 디스크 용량을 사용하고 단일 노드에 들어가지 않거나, 검색요청을 처리하는데 많이 느릴 것 입니다.

이 문제를 해결하기 위해서 Elasticsearch는 파편이라고 불리는 수 많은 조각으로 인덱스를 나눌 수 있습니다. 인덱스를 만들 때 원하는 만큼의 파편 개수를 정의할 수 있습니다. 파편은 클러스터의 노드에 상주하고 있는 모든 기능을 할 수 있는 독립적인 *인덱스*라고 보시면 됩니다.

파편은 두가지 이유로 중요합니다.
* 데이터 분량을 수평적으로 분할하거나 확장할 수 있습니다.
* 파편별(결국은 노드별)로 분산/병렬 처리를 하여 성능/출력을 향상시킬 수 있습니다.
검색 요청을 처리하기 위하여 파편을 어떻게 분산하고 다시 문서로 합치는지에 대한 과정은 전적으로 Elasticsearch가 처리하기 때문에 사용자는 고민하지 않아도 됩니다.

언제 장애가 발생할지 모르는 네트워크/클라우드 같은 환경의 경우에는 파편/노드가 어느 이유던 오프라인 또는 중단에 대한 장애조치 방법으로 유용하고 적극 권장합니다. 이것을 위해 Elasticsearch는 복제 파편(또는 복제본) 이라고 불리는 인덱스 파편의 복사본을 1개 이상 만들 수 있게 해줍니다.

복제 또한 두가지 이유로 중요합니다.
* 파편/노드의 장애에 대응하는 고가용성을 제공합니다. 이 이유로 복제본은 원본과 동일한 노드에 저장하지 않는 것이 중요합니다.
* 검색을 모든 복제본에서 병렬적으로 처리하여 검색분량/결과를 확장할 수 있도록 합니다.

요약하면, 각각의 인덱스는 파편으로 나눠질 수 있습니다. 그리고 0개(복제하지 않음) 이상의 복제본을 가질 수 있습니다. 인덱스를 복제한다면, 최초의 파편(가장 먼저 복제된 파편)과 복제본(최초의 파편 복사본)로 구성될 것 입니다. 인덱스가 생성되는 시점에 파편과 복제본의 수를 정의할 수 있습니다. 인덱스가 생성된 뒤에는 복제본의 수는 동적으로 변경이 가능하나 사후에는 파편에 대한 수는 수정이 불가능합니다.

기본적으로 Elasticsearch의 인덱스는 5개의 파편으로 구성되고 1개의 복제본을 가지게 될 것 입니다. 다시 말해 적어도 2개 이상의 노드로 구성하면 인덱스는 5개의 파편과 5개의 복제파편(1개의 완벽한 복제본)으로 구성되어 인덱스당 총 10개의 파편이 있을 것 입니다.

> Elasticsearch의 파편은 Lucene 인덱스입니다. 1개의 단일 Lucene 인덱스에 가능한 최대 문서 개수가 있습니다. [LUCENE-5843](https://issues.apache.org/jira/browse/LUCENE-5843)에 따르면 그 한계는 2,147,483,519(= Integer.MAX_VALUE - 128)개의 문서입니다. 추가로 [?[_cat/shards](https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html) API를 통해서 파편 사이즈를 모니터링 할 수 있습니다.

기본적인 개념을 가지고 재미난 것을 더 해보도록 하겠습니다.


